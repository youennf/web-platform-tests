<!doctype html>
<meta charset="utf-8">
<title>RTCSctpTransport constructor</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  4.4.2.  RTCPeerConnection.close
    7.    Set the [[SctpTransportState]] slot of connection's [[SctpTransport]] to "closed".
 */

promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  // We use the queue to hold back candidates, so no connection can be established
  const pc1Queue = new IceCandidateQueue(pc1);
  const pc2Queue = new IceCandidateQueue(pc2);

  // Negotiate SCTP transport
  pc1.createDataChannel('test');
  await doSignalingHandshake(pc1, pc2);

  for (const pc of [pc1, pc2]) {
    assert_equals(pc.sctp.state, 'connecting',
      'RTCSctpTransport should be in the connecting state');

    // Triggered after the peers connected
    pc.sctp.onstatechange = t.step_func(() => {
      assert_equals(pc.sctp.state, 'connected');
      resolver.resolve();
    });
  }

  // Let the peers connect
  exchangeIceCandidates(pc1Queue, pc2Queue);

  await resolver;
}, 'RTCSctpTransport.onstatechange should fire when the state changes', {
  timeout: 5000
});

</script>
