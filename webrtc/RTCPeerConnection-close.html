<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.createDataChannel</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

/*
  4.4.2.  RTCPeerConnection.close
    6.    Set the [[ReadyState]] slot of each of connection's RTCDataChannels to "closed".

  Note: This test assumes that the implementation can handle a minimum of 24 data channels.
 */
test((t) => {
  const pc = new RTCPeerConnection();

  // Create 24 channels, some of them negotiated
  const dcs = [];
  for (let i = 0; i < 24; ++i) {
    const options = {};
    if (i % 2 === 0) {
      options.negotiated = true;
      options.id = i;
    }
    const dc = pc.createDataChannel(`test-channel-${i}`, options);
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    dcs.push(dc);
  }

  // Stop!
  pc.close();

  // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's sync
  for (const dc of dcs) {
    assert_equals(dc.readyState, 'closed',
      'Channel should be closed after closing the peer connection');
  }
}, 'Closing the peer connection should close all channels (before connection establishment)', {
  timeout: 5000
});

for (const local of [true, false]) {
  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const dcs = [];

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2);
    const id = dc1.id;
    assert_not_equals(dc1.readyState, 'closed',
      'Channel may not be closed after connection establishment');
    dcs.push(dc1);
    assert_not_equals(dc2.readyState, 'closed',
      'Channel may not be closed after connection establishment');
    dcs.push(dc2);

    // Create 23 further channels, some of them negotiated
    for (let i = id + 1; i < (id + 24); ++i) {
      const createChannel = (pc, options) => {
        const dc = pc.createDataChannel(`test-channel-${i}`, options);
        assert_not_equals(dc.readyState, 'closed',
          'Channel may not be closed after connection establishment');
        dcs.push(dc);
      };

      const options = {};
      if ((local && i % 2 === 0) || (!local && i %2 === 1)) {
        options.negotiated = true;
        options.id = i;
      }

      // Note: We explicitly don't add negotiated channels to both sides to see if the
      //       implementation can cope with that.
      createChannel(local ? pc1 : pc2, options);
    }

    // Stop!
    (local ? pc1 : pc2).close();

    // Note: The spec doesn't mention anything related to schedule 'close', so assuming it's
    //       sync
    for (const dc of dcs) {
      assert_equals(dc.readyState, 'closed',
        'Channel should be closed after closing the peer connection');
    }
  }, `Closing the ${local ? 'local' : 'remote'} peer connection should close all channels (after
  connection establishment)`, {
    timeout: 5000
  });
}

promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  await createDataChannelPair(pc1, pc2);
  // Stop!
  pc1.close();
  pc2.close();

  assert_equals(pc1.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
  assert_equals(pc2.sctp.state, 'closed', 'RTCSctpTransport should be in the closed state');
}, 'Closing the peer connection should set the SCTP transport to closed', {
  timeout: 5000
});

/*
  TODO: Cover all the other steps defined by 4.4.2.
 */
</script>
