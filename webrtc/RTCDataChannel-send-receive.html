<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel send/receive</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// The following helper functions are called from RTCPeerConnection-helper.js:
//  createDataChannelPair
//  awaitMessage
//  blobToArrayBuffer
//  assert_equals_typed_array

// Note: bufferedAmount after send is covered in RTCDataChannel-bufferedAmount

/*
  6.2.  RTCDataChannel
    interface RTCDataChannel : EventTarget {
      ...
      readonly  attribute RTCDataChannelState readyState;
      readonly  attribute unsigned long       bufferedAmount;
                attribute EventHandler        onmessage;
                attribute DOMString           binaryType;

      void send(USVString data);
      void send(Blob data);
      void send(ArrayBuffer data);
      void send(ArrayBufferView data);
    };
 */

// Simple ASCII encoded string
const helloString = 'hello';
// ASCII encoded buffer representation of the string
const helloBuffer = Uint8Array.of(0x68, 0x65, 0x6c, 0x6c, 0x6f);
const helloBlob = new Blob([helloBuffer]);
// Unicode string with multiple code units
const unicodeString = '世界你好';

// Array buffer types to test
const arrayBuffers = [
  ['Int8Array', Int8Array.of(127, 126, 0, -128)],
  ['Uint8Array', Uint8Array.of(255, 254, 253, 0)],
  ['Uint8ClampedArray', Uint8ClampedArray.of(257, 256, -1, -2)],
  ['Int16Array', Int16Array.of(32767, 32766, 0, -32768)],
  ['Uint16Array', Uint16Array.of(65535, 65534, 65533, 0)],
  ['In32Array', Int32Array.of(2147483647, 2147483646, 0, -2147483648)],
  ['Uint32Array', Uint32Array.of(4294967295, 4294967294, 4294967293, 0)],
  ['Flaot32Array', Float32Array.of(1.0, 0.75, 0.5, 0.25)],
  ['Float64Array', Float64Array.of(1.0, 0.75, 0.5, 0.25)],
  ['DataView', new DataView(helloBuffer.buffer)],
];

// Empty buffers
const emptyBuffer = new Uint8Array(0);
const emptyBlob = new Blob([emptyBuffer]);

const channelOptionsVariants = [
  ['In-band negotiated channel', {}],
  ['Negotiated channel', [
    {
      negotiated: true,
      id: 42
    }, {
      negotiated: true,
      id: 42
    }
  ]],
  ['Asymmetric negotiated channel', [
    {
      negotiated: true,
      id: 42
    }, {
      negotiated: true,
      id: 42,
      // Note: Make sure that your tests can cope with unordered messages on the local side!
      ordered: false,
    }
  ]],
];

for (const [description, channelOptions] of channelOptionsVariants) {
  /*
     6.2.  send()
      2.  If channel's [[ReadyState]] slot is not open, throw an InvalidStateError.
   */
  test((t) => {
    const pc = new RTCPeerConnection();
    const channel = pc.createDataChannel('test', channelOptions);
    assert_throws('InvalidStateError', () => channel.send(helloString));
  }, `${description}: Calling send() when not open should throw InvalidStateError`, {
    timeout: 5000
  });

  /*
    6.2.  The send() method is overloaded to handle different data argument types.

          Acceptable: string, Blob, ArrayBuffer, ArrayBufferView
  */
  const invalidMessageTypes = [
    null,
    undefined,
    42,
  ];

  for (const messageType of invalidMessageTypes) {
    promise_test(async (t) => {
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const [dc1] = await createDataChannelPair(pc1, pc2, {channelOptions: channelOptions});

      assert_throws(TypeError, () => dc1.send(messageType));
    }, `${description}: Calling send() with ${messageType} should throw TypeError`, {
      timeout: 5000
    });
  }

  /*
    6.2.  send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          string object
            Let data be a byte buffer that represents the result of encoding the
            method's argument as UTF-8 [...]

    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Text
              a new DOMString containing data
   */
  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    dc1.send(helloString);

    const message = await awaitMessage(dc2);
    assert_equals(typeof message, 'string', 'Expect message to be a string');
    assert_equals(message, helloString);
  }, `${description}: Should be able to send (local) simple string and receive (remote) as
  string`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    dc2.send(helloString);

    const message = await awaitMessage(dc1);
    assert_equals(typeof message, 'string', 'Expect message to be a string');
    assert_equals(message, helloString);
  }, `${description}: Should be able to send (remote) simple string and receive (local) as
  string`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    dc1.send(unicodeString);

    const message = await awaitMessage(dc2);
    assert_equals(typeof message, 'string', 'Expect message to be a string');
    assert_equals(message, unicodeString);
  }, `${description}: Should be able to send unicode string and receive as unicode string`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(helloString);

    const message = await awaitMessage(dc2);
    assert_equals(typeof message, 'string', 'Expect message to be a string');
    assert_equals(message, helloString);
  }, `${description}: Should ignore binaryType and always receive string message as string`, {
    timeout: 5000
  });

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          ArrayBufferView object
            Let data be the data stored in the section of the buffer described
            by the ArrayBuffer object that the ArrayBufferView object references
            and increase the value of the [[BufferedAmount]] slot with the the length
            of the ArrayBufferView in bytes.

    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Binary and binaryType is "arraybuffer"
              a new ArrayBuffer object, created in the relevant Realm of the WebSocket
              object, whose contents are data

    [WebIDL]
    4.1.  ArrayBufferView
      typedef (Int8Array or Int16Array or Int32Array or
        Uint8Array or Uint16Array or Uint32Array or Uint8ClampedArray or
        Float32Array or Float64Array or DataView) ArrayBufferView;
   */
  for (const [name, arrayBuffer] of arrayBuffers) {
    promise_test(async (t) => {
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
      dc2.binaryType = 'arraybuffer';

      dc1.send(arrayBuffer);

      const messageBuffer = await awaitMessage(dc2);
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, arrayBuffer);
    }, `${description}: Should be able to send ${name} message and receive as ArrayBuffer`, {
      timeout: 5000
    });
  }

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const helloBufferWithOffset = new Uint8Array(helloBuffer.buffer, 2);

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(helloBufferWithOffset);

    const messageBuffer = await awaitMessage(dc2);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloBufferWithOffset);
  }, `${description}: Should be able to send Uint8Array (with offset) message and receive as
  ArrayBuffer`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const helloView = new DataView(helloBuffer.buffer, 2);

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(helloView);

    const messageBuffer = await awaitMessage(dc2);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloView);
  }, `${description}: Should be able to send DataView (with offset) message and receive as
  ArrayBuffer`, {
    timeout: 5000
  });

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          ArrayBuffer object
            Let data be the data stored in the buffer described by the ArrayBuffer
            object and increase the value of the [[BufferedAmount]] slot with the
            length of the ArrayBuffer in bytes.
   */
  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(helloBuffer.buffer);

    const messageBuffer = await awaitMessage(dc2);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloBuffer);
  }, `${description}: Should be able to send ArrayBuffer message and receive as ArrayBuffer`, {
    timeout: 5000
  });

  /*
    6.2. send()
      3.  Execute the sub step that corresponds to the type of the methods argument:

          Blob object
            Let data be the raw data represented by the Blob object and increase the
            value of the [[BufferedAmount]] slot with the size of data, in bytes.
   */
  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(helloBlob);

    const messageBuffer = await awaitMessage(dc2);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloBuffer);
  }, `${description}: Should be able to send Blob message and receive as ArrayBuffer`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const slicedHelloBlob = helloBlob.slice(2);
    const helloBufferWithOffset = new Uint8Array(helloBuffer.buffer, 2);

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(slicedHelloBlob);

    const messageBuffer = await awaitMessage(dc2);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloBufferWithOffset);
  }, `${description}: Should be able to send Blob (with offset) message and receive as ArrayBuffer`, {
    timeout: 5000
  });

  /*
    TODO: Update this once https://github.com/w3c/webrtc-pc/issues/1825 is resolved

    [WebSocket]
    9.3.3.  When a WebSocket message has been received with type type and data data, the
            user agent must queue a task to follow these steps:
        2.  Let dataForEvent be determined by switching on type and binaryType:

            type indicates that the data is Binary and binaryType is "blob"
              a new Blob object, created in the relevant Realm of the WebSocket object,
              that represents data as its raw data [FILEAPI]
   */
  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'blob';

    dc1.send(helloBuffer);

    const messageBlob = await awaitMessage(dc2);
    assert_true(messageBlob instanceof Blob,
      'Expect received messageBlob to be a Blob');
    const messageBuffer = await blobToArrayBuffer(messageBlob);
    assert_true(messageBuffer instanceof ArrayBuffer,
      'Expect messageBuffer to be an ArrayBuffer');
    assert_equals_typed_array(messageBuffer, helloBuffer);
  }, `${description}: Should be able to send ArrayBuffer message and receive as Blob`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    dc1.send('');
    t.step_timeout(() => assert_unreached('Receiving empty string timed out'), 3000);

    const message = await awaitMessage(dc2);
    assert_equals(message, '', 'Data should be an empty string');
  }, `${description}: Should be able to transmit an empty string`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';

    dc1.send(emptyBuffer);
    t.step_timeout(() => assert_unreached('Receiving empty buffer timed out'), 3000);

    const messageBuffer = await awaitMessage(dc2)
    assert_equals(messageBuffer.byteLength, 0, 'Data should be an empty ArrayBuffer');
  }, `${description}: Should be able to transmit an empty Uint8Array`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'blob';

    dc1.send(emptyBlob);
    t.step_timeout(() => assert_unreached('Receiving empty buffer timed out'), 3000);

    const messageBlob = await awaitMessage(dc2);
    assert_equals(messageBlob.size, 0, 'Data should be an empty Blob');
  }, `${description}: Should be able to transmit an empty Blob`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    return createDataChannelPair(pc1, pc2, { channelOptions: channelOptions })
    .then(([dc1, dc2]) => {
      assert_equals(dc2.binaryType, 'blob', 'Expect initial binaryType value to be blob');
      dc1.send(helloBuffer);
      return awaitMessage(dc2);
    })
    .then(messageBlob => {
      assert_true(messageBlob instanceof Blob, 'Expect received messageBlob to be a Blob');
      return blobToArrayBuffer(messageBlob);
    })
    .then(messageBuffer => {
      assert_true(messageBuffer instanceof ArrayBuffer,
        'Expect messageBuffer to be an ArrayBuffer');
      assert_equals_typed_array(messageBuffer, helloBuffer);
    });
  }, `${description}: Setting binaryType should receive message as Blob by default`);

  // Test sending 3 messages with different types on one channel:
  // helloBuffer, unicodeString, helloBlob
  promise_test(async (t) =>{
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const receivedMessages = [];

    const onMessage = t.step_func(event => {
      const { data } = event;
      receivedMessages.push(data);

      if(receivedMessages.length === 3) {
        assert_equals_typed_array(receivedMessages[0], helloBuffer);
        assert_equals(receivedMessages[1], unicodeString);
        assert_equals_typed_array(receivedMessages[2], helloBuffer);

        resolver.resolve();
      }
    });

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc2.binaryType = 'arraybuffer';
    dc2.addEventListener('message', onMessage);

    dc1.send(helloBuffer);
    dc1.send(unicodeString);
    dc1.send(helloBlob);

    await resolver;
  }, `${description}: Sending multiple messages with different types should succeed`, {
    timeout: 5000
  });

  // Test receiving 4 messages with different types on one channel:
  // Blob, DOMString, ArrayBuffer, Blob
  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    const receivedMessages = [];

    dc2.onmessage = t.step_func(event => {
      const { data } = event;
      receivedMessages.push(data);
      dc2.binaryType = receivedMessages.length === 3 ? 'blob' : 'arraybuffer';

      if (receivedMessages.length === 4) {
        Promise.all([
          blobToArrayBuffer(receivedMessages[0]),
          blobToArrayBuffer(receivedMessages[3]),
        ])
        .then((blobMessages) => {
          receivedMessages[0] = blobMessages[0];
          receivedMessages[3] = blobMessages[1];

          assert_equals_typed_array(receivedMessages[0], helloBuffer);
          assert_equals(receivedMessages[1], unicodeString);
          assert_equals_typed_array(receivedMessages[2], helloBuffer);
          assert_equals_typed_array(receivedMessages[3], helloBuffer);

          resolver.resolve();
        }).catch(t.step_func(err =>
          assert_unreached(`Unexpected promise rejection: ${err}`)));
      }
    });

    dc1.send(helloBuffer);
    dc1.send(unicodeString);
    dc1.send(helloBlob);
    dc1.send(helloBlob);

    await resolver;
  }, `${description}: Receiving multiple messages with different types should succeed`, {
    timeout: 5000
  });

  /*
    6.2.  send()
      4.  If the size of data exceeds the value of maxMessageSize on channel's
          associated RTCSctpTransport, throw a TypeError.

    Note: maxMessageSize is extensively tested in RTCSctpTransport-maxMessageSize. In
          this test, we only care about whether the data reaches the other peer as
          expected or that TypeError is correctly raised.
  */
  const messageLengthsAndTimeout = [
    // 1 KiB
    [1024, 5000],
    // 16 KiB, was the maximum message size when sending from Firefox to Chrome
    [16384, 5000],
    // 64 KiB, is the maximum message size in Chrome
    [65536, 5000],
    // 128 KiB, violates the message-oriented principle when received by Chrome
    [131072, 5000],
    // 256 KiB, is the default buffer size of usrsctp
    [262144, 5500],
    // 512 KiB, > 256 KiB fails in Chrome by closing channels
    [524288, 6000],
    // 1 MiB
    [1048576, 7000],
    // 16 MiB
    [16777216, 37000],
    // 32 MiB
    [33554432, 69000],
  ];
  for (const [messageLength, timeout] of messageLengthsAndTimeout) {
    promise_test(async (t) => {
      const resolver = new Resolver();
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const message = new Uint8Array(messageLength).fill(0xfe);

      const [dc1, dc2] = await createDataChannelPair(pc1, pc2, {
        channelLabel: '╯°□°）╯︵ ┻━┻',
        channelOptions: channelOptions
      });
      dc2.binaryType = 'arraybuffer';

      // Ensure the channels are not being closed
      for (const dc of [dc1, dc2]) {
        dc.onclose = t.step_func(() => {
          assert_unreached('Channel should not become closed');
        });
      }

      // Ensure the data reaches the other peer (and the message-oriented principle is not
      // violated)
      dc2.onmessage = t.step_func(event => {
        const { data } = event;
        assert_equals_typed_array(data, message,
          'Send data should equal receive data');
        resolver.resolve();
      });

      // Send or fail with TypeError
      try {
        dc1.send(message);
      } catch (e) {
        assert_equals(e.name, 'TypeError',
          'Should throw TypeError in case the message is too large');
        resolver.resolve();
      }

      await resolver;
    }, `${description}: Sending and receiving ${messageLength} bytes should succeed or raise
    TypeError`, {
      timeout: timeout
    });

    promise_test(async (t) => {
      const resolver = new Resolver();
      const pc1 = new RTCPeerConnection();
      const pc2 = new RTCPeerConnection();
      t.add_cleanup(() => pc1.close());
      t.add_cleanup(() => pc2.close());

      const message = new Uint8Array(messageLength + 1).fill(0xfe);

      const [dc1, dc2] = await createDataChannelPair(pc1, pc2, {
        channelLabel: '╯°□°）╯︵ ┻━┻',
        channelOptions: channelOptions,
        modifyAnswer: (answer) => {
          // Lower the remote maximum message size (if needed)
          const mmsAttribute = answer.sdp.match(/^a=max-message-size:(\d+)/m);
          let mms = mmsAttribute === null ? 65536 : parseInt(mmsAttribute[1], 10);
          if (mms === 0) {
            mms = Number.POSITIVE_INFINITY;
          }
          if (messageLength < mms) {
            if (mmsAttribute === null) {
              answer.sdp = answer.sdp.replace(
                /^(m=application \d+ [^ ]*DTLS\/SCTP[^\r\n]*\r\n)/m,
                `$1a=max-message-size:${messageLength}\r\n`);
            } else {
              answer.sdp = answer.sdp.replace(/^(a=max-message-size:)(\d+)/m, `$1${messageLength}`);
            }
          }
          return answer;
        }
      });

      // Ensure the channels are not being closed
      for (const dc of [dc1, dc2]) {
        dc.onclose = t.step_func(() => {
          assert_unreached('Channel should not become closed');
        });
      }

      // Ensure no data reaches the other peer
      dc2.onmessage = t.step_func(() => {
        assert_unreached('Channel should not receive any data');
      });

      // Send or fail with TypeError
      assert_throws(new TypeError(), () => dc1.send(message),
        'Should throw TypeError in case the message is too large');
      dc1.send(message);

      // Give the implementation a chance to misbehave and close channels
      // Note: Tested that in Chrome and it really needs the long timeout
      t.step_timeout(t.step_func_done(), Math.min(timeout, 10000));

      await resolver;
    }, `${description}: Sending and receiving ${messageLength} +1 bytes should raise TypeError`, {
      timeout: timeout
    });
  }

  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // 16 KiB * 64 -> 1 MiB
    const message = new Uint8Array(16384).fill(0xfe);
    const nMessages = 64;

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    let nMessagesReceived = 0;
    dc2.binaryType = 'arraybuffer';

    // Ensure the data reaches dc2
    dc2.onmessage = t.step_func(event => {
      const {data} = event;
      assert_equals_typed_array(data, message,
        'Received data should be equal to sent data');
      if (++nMessagesReceived === nMessages) {
        resolver.resolve();
      }
    });

    // Send messages
    for (let i = 0; i < nMessages; ++i) {
      dc1.send(message);
    }
    t.step_timeout(() => {
      assert_unreached('Data should have been received by now (timeout reached)');
    }, 4000);

    await resolver;
  }, `${description}: Sending and receiving 16 KiB x64 should succeed`, {
    timeout: 7000
  });

  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // 16 KiB * 256 -> 4 MiB
    const message = new Uint8Array(16384).fill(0xfe);
    const nMessages = 256;

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    let nMessagesReceived1 = 0;
    let nMessagesReceived2 = 0;
    dc1.binaryType = 'arraybuffer';
    dc2.binaryType = 'arraybuffer';

    const maybeDone = () => {
      if (nMessagesReceived1 === nMessages && nMessagesReceived2 === nMessages) {
        resolver.resolve();
      }
    };

    // Ensure the data reaches both peers
    dc1.onmessage = t.step_func(event => {
      const {data} = event;
      assert_equals_typed_array(data, message,
        'Received data should be equal to sent data');
      ++nMessagesReceived1;
      maybeDone();
    });
    dc2.onmessage = t.step_func(event => {
      const {data} = event;
      assert_equals_typed_array(data, message,
        'Received data should be equal to sent data');
      ++nMessagesReceived2;
      maybeDone();
    });

    // Send messages
    for (let i = 0; i < nMessages; ++i) {
      dc1.send(message);
      dc2.send(message);
    }
    t.step_timeout(() => {
      assert_unreached('Data should have been received by now (timeout reached)');
    }, 25000);

    await resolver;
  }, `${description}: Sending and receiving 16 KiB x256 on both peer simultaneously should
  succeed`, {
    timeout: 28000
  });

  // Note: This test isn't particularly useful as both peers are on the same machine...
  //       but who knows.
  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // 2048 messages of decreasing length
    const messages = Array.from(new Array(2048), (_, i) => `${i % 10}`.repeat(2048 - i));

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    let nMessagesReceived = 0;
    dc2.binaryType = 'arraybuffer';

    // Ensure the data reaches dc2
    dc2.onmessage = t.step_func(event => {
      const {data} = event;
      assert_equals(data, messages[nMessagesReceived],
        'Received data should be equal to sent data');
      if (++nMessagesReceived === messages.length) {
        resolver.resolve();
      }
    });

    // Send messages
    for (const message of messages) {
      dc1.send(message);
    }
    t.step_timeout(() => {
      assert_unreached('Data should have been received by now (timeout reached)');
    }, 5000);

    await resolver;
  }, `${description}: Sending and receiving 2048 messages should succeed and keep order`, {
    timeout: 7000
  });

  // Based on https://bugzilla.mozilla.org/show_bug.cgi?id=1413198
  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    // Note: Since this is a race, we need a large amount of data. 1 MiB should be sufficient.
    //       We're assuming the implementation can queue at least 16 messages of size 64 KiB.
    //       The small message size has been chosen because every implementation supports 64 KiB.
    const message = new Uint8Array(65536).fill(0xfe);
    const nMessages = 16;

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    let nMessagesReceived = 0;
    dc2.binaryType = 'arraybuffer';

    // Ensure dc2 has received all messages once being closed
    dc2.onclose = t.step_func(() => {
      assert_equals(nMessagesReceived, nMessages,
        'Remote channel should have received all messages before becoming closed');
      resolver.resolve();
    });

    // Ensure the data reaches dc2
    dc2.onmessage = t.step_func(event => {
      const {data} = event;
      assert_equals_typed_array(data, message,
        'Received data should be equal to sent data');
      ++nMessagesReceived;
    });

    // Fill the send buffer as fast as possible and close immediately
    for (let i = 0; i < nMessages; ++i) {
      dc1.send(message);
    }
    dc1.close();
    t.step_timeout(() => {
      assert_unreached('Channel should have been closed by now (timeout reached)');
    }, 4000);

    await resolver;
  }, `${description}: Closing a channel (local) with pending data should transfer that data
  before becoming closed`, {
    timeout: 7000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    dc1.close();
    assert_throws('InvalidStateError', () => dc1.send(helloString));
  }, `${description}: Sending after the channel has been closed (local) should raise
  InvalidStateError`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc1.onclose = t.step_func(() => {
      assert_throws('InvalidStateError', () => dc1.send(helloString));
      resolver.resolve();
    });

    dc2.close();
    t.step_timeout(() => {
      assert_unreached('Channel should have been closed by now (timeout reached)');
    }, 3000);

    await resolver;
  }, `${description}: Sending after the channel has been closed (remote) should raise
  InvalidStateError`, {
    timeout: 5000
  });

  promise_test(async (t) => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });

    pc1.close();
    assert_throws('InvalidStateError', () => dc1.send(helloString));
  }, `${description}: Sending after the peer connection has been closed (local) should raise
  InvalidStateError`, {
    timeout: 5000
  });

  promise_test(async (t) =>{
    const resolver = new Resolver();
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    t.add_cleanup(() => pc2.close());

    const [dc1] = await createDataChannelPair(pc1, pc2, { channelOptions: channelOptions });
    dc1.onclose = t.step_func(() => {
      assert_throws('InvalidStateError', () => dc1.send(helloString));
      resolver.resolve();
    });

    pc2.close();
    t.step_timeout(() => {
      assert_unreached('Channel should have been closed by now (timeout reached)');
    }, 3000);

    await resolver;
  }, `${description}: Sending after the peer connection has been closed (remote) should raise
  InvalidStateError`, {
    timeout: 5000
  });
}

/*
  Untestable

  6.2.  send()
    2.  Queue data for transmission on channel's underlying data transport. If queuing
        data is not possible because not enough buffer space is available, throw an
        OperationError.

        NOTE
        The actual transmission of data occurs in parallel. If sending data leads to
        an SCTP-level error, the application will be notified asynchronously through
        onerror.
*/
</script>
