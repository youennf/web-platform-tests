<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel id attribute</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// This is the maximum number of streams, NOT the maximum stream ID (which is 65534)
// See: https://tools.ietf.org/html/draft-ietf-rtcweb-data-channel-13#section-6.2
const nStreams = 65535;

/*
  6.1.
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL] [...]
 */
promise_test(async (t) => {
  const pc = new RTCPeerConnection;
  t.add_cleanup(() => pc.close());

  const dc1 = pc.createDataChannel('');
  const ids = new UniqueSet();

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
  // "active".
  const answer = {
    type: 'answer',
    sdp: pc.localDescription.sdp.replace('actpass', 'active')
  };
  await pc.setRemoteDescription(answer);

  // Since the remote description had an 'active' DTLS role, we're the server
  // and should use odd data channel IDs, according to rtcweb-data-channel.
  assert_equals(dc1.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
  const dc2 = pc.createDataChannel('another');
  assert_equals(dc2.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc2.id})`);

  // Ensure IDs are unique
  ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`);
  ids.add(dc2.id, `Channel ID ${dc2.id} should be unique`);
}, 'DTLS client uses odd data channel IDs', {
  timeout: 5000
});

promise_test(async (t) => {
  const pc = new RTCPeerConnection;
  t.add_cleanup(() => pc.close());

  const dc1 = pc.createDataChannel('');
  const ids = new UniqueSet();

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
  // 'passive'.
  const answer = {
    type: 'answer',
    sdp: pc.localDescription.sdp.replace('actpass', 'passive')
  };
  await pc.setRemoteDescription(answer);

  // Since the remote description had a 'passive' DTLS role, we're the client
  // and should use even data channel IDs, according to rtcweb-data-channel.
  assert_equals(dc1.id % 2, 0,
    `Channel created by the DTLS client role must be even (was ${dc1.id})`);
  const dc2 = pc.createDataChannel('another');
  assert_equals(dc2.id % 2, 0,
    `Channel created by the DTLS client role must be even (was ${dc1.id})`);

  // Ensure IDs are unique
  ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`);
  ids.add(dc2.id, `Channel ID ${dc2.id} should be unique`);
}, 'DTLS server uses even data channel IDs', {
  timeout: 5000
});

/*
  Check if the implementation allows using in-band negotiated channels with a specific ID (which
  is now a spec violation).
 */
promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc1 = pc1.createDataChannel('', {
    negotiated: false,
    id: 42
  });
  dc1.onopen = t.step_func(() => {
    dc1.send(':(');
  });

  const dc2 = pc2.createDataChannel('', {
    negotiated: false,
    id: 42
  });
  dc2.onmessage = t.step_func(() => {
    assert_unreached('Channel established with same ID using negotiated=false');
  });

  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);

  t.step_timeout(t.step_func_done(), 2000);
  await resolver;
}, 'In-band negotiation with a specific ID should not be allowed', {
  timeout: 5000
});

/*
  Check if the implementation still follows the odd/even role correctly if we annoy it with
  negotiated channels not following that rule.

  Note: This test assumes that the implementation can handle a minimum of 40 data channels.
 */
promise_test(async (t) => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  exchangeIceCandidates(pc1, pc2);
  const dcs = [];
  const negotiatedDcs = [];
  const ids = new UniqueSet();

  // Create 10 DCEP-negotiated channels with pc1
  // Note: These should not have any associated valid ID at this point
  for (let i = 0; i < 10; ++i) {
    const dc = pc1.createDataChannel('before-connection');
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    dcs.push(dc);
  }

  // Create 10 negotiated channels with pc1 violating the odd/even rule
  for (let id = 0; id < 20; id += 2) {
    const dc = pc1.createDataChannel(`negotiated-not-odd-${id}-before-connection`, {
      negotiated: true,
      id: id,
    });
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    negotiatedDcs.push([dc, id]);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  await doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  });

  for (const dc of dcs) {
    assert_equals(dc.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc.id})`);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  // Create 10 channels with pc1
  for (let i = 0; i < 10; ++i) {
    const dc = pc1.createDataChannel('after-connection');
    assert_equals(dc.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc.id})`);
    dcs.push(dc);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  // Create 10 negotiated channels with pc1 violating the odd/even rule
  for (let i = 0; i < 10; ++i) {
    // Generate a valid even ID that has not been taken, yet.
    let id = 20;
    while (ids.has(id)) {
      id += 2;
    }
    const dc = pc1.createDataChannel(`negotiated-not-odd-${i}-after-connection`, {
      negotiated: true,
      id: id,
    });
    negotiatedDcs.push([dc, id]);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  // Since we've added new channels, let's check again that the odd/even role is not violated
  for (const dc of dcs) {
    assert_equals(dc.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc.id})`);
  }

  // Let's also make sure the negotiated channels have kept their ID
  for (const [dc, id] of negotiatedDcs) {
    assert_equals(dc.id, id, 'Negotiated channels should keep their assigned ID');
  }
}, 'Odd/even role should not be violated when mixing with negotiated channels', {
  timeout: 5000
});

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted AFTER
  establishing a peer connection.

  6.1.  createDataChannel
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL], and skip
        to the next step. If no available ID could be generated, or if the value of the
        [[DataChannelId]] slot is being used by an existing RTCDataChannel, throw an
        OperationError exception.

  TODO: Needs updating once https://github.com/w3c/webrtc-pc/pull/1848 has been approved!
 */
promise_test(async (t) => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const ids = new UniqueSet();

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  const [dc1, dc2] = await createDataChannelPair(pc1, pc2, {
    channelLabel: 'initial',
    modifyOffer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    modifyAnswer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  });

  // At this point, one channel id is already taken and it MUST be odd since pc1 created it
  assert_equals(dc1.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
  assert_equals(dc2.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc2.id})`);
  ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`); // dc2 is the same channel on the other peer

  // Create 65534 further channels
  // Note: Since 65535 streams is a SHOULD, we may have less than that
  for (let i = 1; i < nStreams; ++i) {
    let dc;

    // The first two channels and all even streams need to be created by pc2
    if (i < 2 || i % 2 === 0) {
      try {
        dc = pc2.createDataChannel('this is going to be fun');
      } catch (e) {
        assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
        break;
      }
      assert_equals(dc.id % 2, 0,
        `Channel #${i + 2} created by the DTLS client role must be even (was ${dc.id})`);
    } else {
      try {
        dc = pc1.createDataChannel('this is going to be fun, too');
      } catch (e) {
        assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
        break;
      }
      assert_equals(dc.id % 2, 1,
        `Channel #${i + 2} created by the DTLS server role must be odd (was ${dc.id})`);
    }

    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  // Try creating one further channel on both sides. The attempt should fail.
  assert_throws('OperationError', () =>
    pc1.createDataChannel('this is too exhausting!'));
  assert_throws('OperationError', () =>
    pc2.createDataChannel('this is too exhausting!'));
}, 'Creating a channel after exhausting the maximum number of channels should throw ' +
  'OperationError (after connection establishment)', {
  timeout: 20000
});

/*
  Ensure an ID cannot be reused before the former channel with the same ID has been closed.
  See: https://bugs.chromium.org/p/chromium/issues/detail?id=559394
 */
promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const [dc1, dc2] = await createDataChannelPair(pc1, pc2, { channelLabel: 'test' });

  let done = false;
  assert_not_equals(dc1.id, null, 'Expect dc1.id to be assigned after dc1 opened');
  const id = dc1.id;

  dc2.onclose = t.step_func(() => {
    // Give pc1 a chance to create the new data channel.
    t.step_timeout(() => {
      assert_true(done, 'pc1 should be done creating the new data channel by now');
      resolver.resolve();
    }, 1000);
  });

  // Close immediately and reuse the ID
  // Note: Be aware that this is a race but the JS should always be faster than the SCTP
  //       stream reset dance on the network.
  dc1.close();
  assert_throws('OperationError', () => {
    pc1.createDataChannel('id-reuse', {
      negotiated: true,
      id: id
    })
  });
  done = true;

  await resolver;
}, 'ID reuse should not be possible before the former channel with the same ID closed', {
  timeout: 5000
});

/*
  Ensure an ID can be reused once the former channel with the same ID has been closed.
 */
promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const [dc1] = await createDataChannelPair(pc1, pc2, { channelLabel: 'test' });

  assert_not_equals(dc1.id, null, 'Expect dc1.id to be assigned after dc1 opened');
  const id = dc1.id;

  dc1.onclose = t.step_func(() => {
    // Immediately reuse the channel ID and wait for it to open
    const dc = pc1.createDataChannel('id-reuse', {
      negotiated: true,
      id: id
    });
    dc.onopen = t.step_func(() => resolver.resolve());
    assert_equals(dc.id, id, "Expect dc.id to match former channel's dc1.id");
    t.step_timeout(() => assert_unreached('dc did not open in time'), 3000);
  });

  dc1.close();

  await resolver;
}, 'ID reuse should be possible once the former channel with the same ID closed', {
  timeout: 5000
});

/*
  Create channels until exhaustion, close one, open one (this should work), open another
  (this should fail).

  TODO: Needs updating once https://github.com/w3c/webrtc-pc/pull/1848 has been approved!
 */
promise_test(async (t) => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dcs = [];
  const ids = new UniqueSet();

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  const [dc1, dc2] = await createDataChannelPair(pc1, pc2, {
    channelLabel: 'initial',
    modifyOffer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    modifyAnswer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  });

  // At this point, one channel id is already taken and it MUST be odd since pc1 created it
  assert_equals(dc1.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
  assert_equals(dc2.id % 2, 1,
    `Channel created by the DTLS server role must be odd (was ${dc2.id})`);
  ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`); // dc2 is the same channel on the other peer

  // Create 65534 further channels with pc1
  // Note: Since we do this on pc1 only, IDs should be exhausted after 32767 channels
  for (let i = 1; i < nStreams; ++i) {
    let dc;
    try {
      dc = pc1.createDataChannel('test');
    } catch (e) {
      assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
      break;
    }
    assert_equals(dc.id % 2, 1,
      `Channel #${i + 2} created by the DTLS server role must be even (was ${dc.id})`);

    dcs.push(dc);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  // Try creating one further channel with pc1. The attempt should fail.
  assert_throws('OperationError', () =>
    pc1.createDataChannel('this is too exhausting!'));

  // Close a channel and wait until it's closed
  const id = await new Promise((resolve) => {
    const dc = dcs[0];
    const id = dc.id;
    dc.onclose = () => resolve(id);
    dc.close();
  });

  // Create a new channel, ensure the ID has been reassigned
  const dc = pc1.createDataChannel('reassigned?');
  assert_equals(dc.id, id, `ID ${id} should be reassigned to new channel`);
}, 'Channel IDs should be reassigned after exhaustion in case a channel has been closed', {
  timeout: 20000
});

/*
  Create 66535 channels with the DTLS client role. Ensure the odd/even rule is not violated.
 */
promise_test(async (t) => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  exchangeIceCandidates(pc1, pc2);
  const dcs = [];
  const ids = new UniqueSet();

  // Create 65535+1000 channels with pc1
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it may
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < (nStreams + 1000); ++i) {
    const dc = pc1.createDataChannel('test');
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    dcs.push(dc);
  }

  await doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  });

  for (const dc of dcs) {
    if (dc.readyState !== 'closed') {
      assert_equals(dc.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc.id})`);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }
  }

  // Try creating one further channel on both sides. The attempt should fail since all IDs are
  // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
  assert_throws('OperationError', () =>
    pc1.createDataChannel('this is too exhausting!'));
}, 'Exhausting channels with one peer should not violate the odd/even rule', {
  timeout: 20000
});

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted BEFORE
  establishing a peer connection.

  Be aware that late channel id assignment can currently fail in many places not covered by the
  spec, see: https://github.com/w3c/webrtc-pc/issues/1818

  4.4.1.6.
    2.2.6.  If description negotiates the DTLS role of the SCTP transport, and there is an
            RTCDataChannel with a null id, then generate an ID according to [RTCWEB-DATA-PROTOCOL].
            If no available ID could be generated, then run the following steps:
      1.    Let channel be the RTCDataChannel object for which an ID could not be generated.
      2.    Set channel's [[ReadyState]] slot to "closed".
      3.    Fire an event named error with an OperationError exception at channel.
      4.    Fire a simple event named close at channel.
 */
promise_test(async (t) => {
  const resolver = new Resolver();
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  exchangeIceCandidates(pc1, pc2);
  const dcs = [];
  const ids = new UniqueSet();
  let nExpected = 0;
  let nActualCloses = 0;
  let nActualErrors = 0;

  const maybeDone = t.step_func(() => {
    if (nExpected === nActualCloses && nExpected === nActualErrors) {
      resolver.resolve();
    }
  });

  // Create 65535+2 channels (since 65535 streams is a SHOULD, we may have less than that.)
  // Create two extra channels to possibly trigger the steps in the description.
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it will
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < (nStreams + 2); ++i) {
    let dc;
    try {
      const pc = i % 2 === 1 ? pc1 : pc2;
      dc = pc.createDataChannel('this is going to be fun');
      dc.onclose = t.step_func(() => {
        ++nActualCloses;
        maybeDone();
      });
      dc.onerror = t.step_func((e) => {
        assert_true(e instanceof RTCError, 'Expect error object to be instance of RTCError');
        assert_equals(e.error, 'sctp-failure', "Expect error to be of type 'sctp-failure'");
        ++nActualErrors;
        maybeDone();
      });
    } catch (e) {
      assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
      break;
    }
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    dcs.push([dc, i % 2 === 1]);
  }

  await doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  });

  // Since the spec does not define a specific order to which channels may fail if an ID could
  // not be generated, any of the channels may be affected by the steps of the description.
  for (const [dc, odd] of dcs) {
    if (dc.readyState !== 'closed') {
      assert_equals(dc.id % 2, odd ? 1 : 0,
        `Channels created by the DTLS ${odd ? 'server' : 'client'} role must be
        ${odd ? 'odd' : 'even'} (was ${dc.id})`);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    } else {
      ++nExpected;
    }
  }

  // Try creating one further channel on both sides. The attempt should fail since all IDs are
  // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
  assert_throws('OperationError', () =>
    pc1.createDataChannel('this is too exhausting!'));
  assert_throws('OperationError', () =>
    pc2.createDataChannel('this is too exhausting!'));

  maybeDone();
  await resolver;
}, 'Channel ID exhaustion handling (before and after connection establishment)', {
  timeout: 20000
});

</script>
